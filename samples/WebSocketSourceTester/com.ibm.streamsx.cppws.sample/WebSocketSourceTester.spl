/*
==============================================
# Licensed Materials - Property of IBM
# Copyright IBM Corp. 2018, 2020
==============================================
*/

/*
==============================================
First created on: Feb/23/2020
Last modified on: Mar/02/2020

This example demonstrates the ingestion of text or binary data
from one or more remote WebSocket clients.

You can build this example from command line via the make command by using the
Makefile available in the top-level directory of this example. Inside that
Makefile, it will be necessary to export the STREAMS_CPPWS_TOOLKIT 
environment variable by pointing it to the full path of your 
streamsx.cppws/com.ibm.streamsx.cppws directory.

If you want to build this example inside the Streams Studio, there are certain
build configuration settings needed. Please refer to the streamsx.cppws
toolkit documentation to learn more about those Streams Studio configuration settings.
==============================================
*/
namespace com.ibm.streamsx.cppws.sample;

// We will use the WebSocketSource operator from this namepsace. 
// [Inside the IBM Streams Studio, it is necessary to make the
//  com.ibm.streamsx.cppws as a dependency for this example SPL project.]
// [If you are building this example outside of Streams Studio, then
//  you have to do what is necessary inside the Makefile as explained in 
//  the previous commentary line.]
use com.ibm.streamsx.cppws.op::*;

// This is the main composite for this application.
composite WebSocketSourceTester {
	param
		// WebSocket connectivity related submission time values are defined below.
		// TLS port on which this application will listen for
		// communicating with the remote WebSocket clients.
		expression<uint32> $tlsPort : 
			(uint32)getSubmissionTimeValue("tlsPort", "443");
		// User can optionally specify whether they want a non-TLS endpoint.
		expression<boolean> $nonTlsEndpointNeeded : 
			(boolean)getSubmissionTimeValue("nonTlsEndpointNeeded", "false");
		// Non-TLS (Plain) port on which this application will
		// (optionally) listen for communicating with the remote WebSocket clients.
		expression<uint32> $nonTlsPort : 
			(uint32)getSubmissionTimeValue("nonTlsPort", "80");
		// Server side certificate (.pem) file for the WebSocket server.
		// It is necessary for the users to create a Root CA signed 
		// server side certificate file and point to that file at the time of
		// starting this application. If the user doesn't point to this file
		// at the time of starting the application, then the application will
		// look for a default file named ws-server.pem inside the etc sub-directory
		// of the application. This certificate will be presented to the
		// remote client for validation when it establishes a WebSocket 
		// connection with this application. For doing quick tests, you may save
		// time and effort needed in getting a proper Root CA signed certificate 
		// by going with a simpler option of creating your own self-signed 
		// certificate. Please ensure that using a self-signed certificate is 
		// allowed in your environment. We have provided a set of instructions to
		// create a self signed certificate. Please refer to the following
		// file in the etc sub-directory of this application:
		// etc/creating-a-self-signed-certificate.txt
		expression<rstring> $certificateFileName :
			getSubmissionTimeValue("certificateFileName", "");
		// Is live metrics needed for the WebSocketSource operator?
		expression<boolean> $websocketLiveMetricsUpdateNeeded : 
			(boolean)getSubmissionTimeValue("websocketLiveMetricsUpdateNeeded", "true");
		// Is WebSocket library low level logging needed?
		expression<boolean> $websocketLoggingNeeded : 
			(boolean)getSubmissionTimeValue("websocketLoggingNeeded", "false");
		// Is client message exchange logging needed for debugging?
		expression<boolean> $wsClientSessionLoggingNeeded : 
			(boolean)getSubmissionTimeValue("wsClientSessionLoggingNeeded", "false");
		// Time in seconds to wait before sending data to the STT engines.
		expression<float64> $initDelayBeforeReceivingData :
			(float64)getSubmissionTimeValue("initDelayBeforeReceivingData", "15.0"); 
		// Time interval in seconds during which the WebSocket source operator below should
		// do memory cleanup of any remote client sessions that end abruptly without 
		// closing the connection.
		expression<uint32> $websocketStaleConnectionPurgeInterval :(uint32)
			getSubmissionTimeValue("websocketStaleConnectionPurgeInterval", "10800");
		// Is ipv6 protocol stack available in the Streams machine where the
		// WebSocketSource operator is going to run?
		// Most of the Linux machines will have ipv6. In that case,
		// you can keep the following line as it is.
		// If you don't have ipv6 in your environment, you can set the
		// following submission time value to false.
		expression<boolean> $ipv6Available : (boolean)
			getSubmissionTimeValue("ipv6Available", "true");
		// Specify the number of received messages from a given client after which 
		// an ack should be sent back to that client.
		expression<uint32> $numberOfMessagesToReceiveBeforeAnAck :(uint32)
			getSubmissionTimeValue("numberOfMessagesToReceiveBeforeAnAck", "0");

	type
		// The following is the schema of the first output stream for the
		// WebSocketSource operator. The first three attributes are
		// very important and the other ones are purely optional if some
		// scenarios really require them.
		// rstring strData --> String based data (plain text, JSON and XML) received from the remote client.
		// blob blobData --> Binary based data (audio, video, image etc.) received from the remote client.
		// uint64 clientSessionId --> Unique identifier of a remote client as assigned by this operator. 
		// int32 totalDataBytesReceived --> Number of data bytes received so far from a given clientSessionId.
		// int32 totalTuplesSent --> Total output tuples emitted so far for a given clientSessionId.
		ReceivedData_t = rstring strData, blob blobData, uint64 clientSessionId, 
			int32 totalDataBytesReceived, int32 totalTuplesSent;
		// The following schema is for the second output stream of the
		// WebSocketSource operator. It has one attribute indicating
		// the a given remote client (clientSessionId) which ended the session.
		EndOfClientSessionSignal_t = uint64 clientSessionId;

	graph
		// Receive text data or binary data or both from the
		// remote WebSocket clients.
		(stream<ReceivedData_t> WebSocketRxData as WSRD;
		 stream<EndOfClientSessionSignal_t> EndOfClientSessionSignal as EOCSS) 
			as WebSocketDataReceiver = WebSocketSource() {
			logic
				state: {
					// Initialize the default TLS certificate file name if the 
					// user didn't provide his or her own.
					rstring _certificateFileName = 
						($certificateFileName != "") ?
						$certificateFileName : getThisToolkitDir() + "/etc/ws-server.pem";
				}
				
			param
				tlsPort: $tlsPort;
				certificateFileName: _certificateFileName;
				nonTlsEndpointNeeded: $nonTlsEndpointNeeded;
				nonTlsPort: $nonTlsPort;
				// Initial delay before generating the very first tuple.
				// This is a one time delay when this operator starts up.
				// This delay should give sufficient time for the
				// downstream operator(s) to come up and be ready to
				// receive the data tuples sent by this operator.
				initDelay: $initDelayBeforeReceivingData;
				websocketLiveMetricsUpdateNeeded: $websocketLiveMetricsUpdateNeeded;
				websocketLoggingNeeded: $websocketLoggingNeeded;
				wsClientSessionLoggingNeeded: $wsClientSessionLoggingNeeded;
				websocketStaleConnectionPurgeInterval: $websocketStaleConnectionPurgeInterval;
				ipv6Available: $ipv6Available;
				numberOfMessagesToReceiveBeforeAnAck: $numberOfMessagesToReceiveBeforeAnAck;
			
			// Get these values via custom output functions	provided by this operator.
			output
			    // strData and/or blobData attributes will be automatically
			    // assigned with values by the operator logic.
			    // Other attributes can be assigned manually as done below.
				WSRD: clientSessionId = getClientSessionId(),
					totalDataBytesReceived = getTotalDataBytesReceived(), 
					totalTuplesSent = getTupleCnt();
		}
	
		// Send a signal for every second to measure the payload ingest rate.
		(stream<boolean signal> TimerSignal) = Beacon() {
			param
				period: 1.0;
		}
		
		// This operator receives the content sent by the remote
		// WebSocket client and maintains a tuple counter. 
		// On receiving a timer signal, it computes the number of tuples 
		// received in that time duration.
		// It reports the data ingest rate to the stdout console.
		// 
		// You can extend this example to do your own custom logic
		// to do what is needed. 
		// (e-g: parse the received XML or JSON or binary messages and
		//  do any analytics using the information contained in them.)
		() as MySink1 = Custom(WebSocketRxData as WSRD; 
			EndOfClientSessionSignal as EOCSS; TimerSignal as TS) {
			logic
				state: {
					// Some state variables needed for this example.
					mutable uint64 _tupleCnt = 0ul;
					mutable uint64 _previousTupleCnt = 0;
					mutable int32 _largestPayloadSizeObserved = 0;
					mutable int32 _timerTickCnt = 0;
				}
				
				onTuple WSRD: {
					_tupleCnt++;
					
					// Record the largest payload seen in the incoming message.
					int32 strDataLength = length(strData);
					int32 blobDataLength = size(blobData);
					int32 payloadSize = 
						(strDataLength > blobDataLength) ? strDataLength : blobDataLength;
					
					if(payloadSize > _largestPayloadSizeObserved) {
						_largestPayloadSizeObserved = payloadSize;
					}
					
					// printStringLn("Payload=" + (rstring)WSRD);
				}
				
				onTuple TS: {
					// Compute the per second message arrival rate.
					_timerTickCnt++;
					
					if (_tupleCnt > _previousTupleCnt) {
						printStringLn("_timerTickCnt=" + (rstring)_timerTickCnt + 
							", _tupleCnt=" + (rstring)_tupleCnt + 
							", rate=" + (rstring)(_tupleCnt - _previousTupleCnt) + 
							", largestPayloadSizeObserved=" + 
							(rstring)_largestPayloadSizeObserved);
						_previousTupleCnt = _tupleCnt;
						_largestPayloadSizeObserved = 0;
					}
				}
				
				onTuple EOCSS: {
					// This is an End Of Client Session Signal.
					// You can use this signal arriving on the second incoming port to
					// identify the end of a given remote client. In your own application logic,
					// you may want to add other logic here as you please. 
					appTrc(Trace.debug, "WebSocket session ended for a remote client: " + (rstring)EOCSS);
				}
		} // End of Custom operator,
}
